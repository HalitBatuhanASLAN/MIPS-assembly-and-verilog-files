module mul_control (
    input  wire clk,
    input  wire rst,
    input  wire start,
    input  wire cnt_zero,    // Datapath'ten gelir: Sayaç bitti mi?
    input  wire lsb_is_one,  // Datapath'ten gelir: Çarpanın son biti 1 mi?
    
    // Datapath'e giden komutlar
    output reg  ld_operands, // Girdileri (A ve B) yükle
    output reg  clr_product, // Sonucu (Product) sıfırla
    output reg  add_enable,  // Toplama yap
    output reg  shift_enable,// Sağa kaydır
    output reg  cnt_load,    // Sayacı N değerine kur
    output reg  cnt_dec,     // Sayacı bir azalt
    
    // Dış dünyaya giden durum sinyalleri
    output reg  busy,        // Hesaplama sürüyor
    output reg  done         // Hesaplama bitti
);

    // 1. DURUM TANIMLARI (STATES) [cite: 35]
    localparam [1:0] 
        IDLE = 2'b00,
        LOAD = 2'b01,
        RUN  = 2'b10,
        DONE = 2'b11;

    reg [1:0] state, next_state;

    // --------------------------------------------------------
    // BLOK 1: Sequential State Register (Durum Kaydedici)
    // Sadece saat darbesiyle durum değiştirir. [cite: 29]
    // --------------------------------------------------------
    always @(posedge clk) begin
        if (rst) 
            state <= IDLE;
        else 
            state <= next_state;
    end

    // --------------------------------------------------------
    // BLOK 2: Next-State Logic (Gelecek Durum Mantığı)
    // Combinational logic - Bir sonraki durumun ne olacağına karar verir. [cite: 30]
    // --------------------------------------------------------
    always @* begin
        // Varsayılan atama (Latch oluşumunu engeller)
        next_state = state;

        case (state)
            IDLE: begin
                if (start)      // Start geldiyse yükleme aşamasına geç
                    next_state = LOAD;
                else
                    next_state = IDLE;
            end

            LOAD: begin
                // Bir cycle içinde yükleme yapılır ve hemen hesaplamaya geçilir
                next_state = RUN;
            end

            RUN: begin
                if (cnt_zero)   // Sayaç sıfırlandıysa işlem bitmiştir
                    next_state = DONE;
                else            // Aksi halde döngüye devam
                    next_state = RUN;
            end

            DONE: begin
                // Bir cycle DONE sinyali verip başa dön
                next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // --------------------------------------------------------
    // BLOK 3: Output Logic (Çıkış Mantığı)
    // Combinational logic - Duruma göre sinyalleri üretir. [cite: 31]
    // --------------------------------------------------------
    always @* begin
        // Varsayılan değerler (Önemli: Her cycle başında sinyalleri sıfırlarız)
        ld_operands  = 0;
        clr_product  = 0;
        add_enable   = 0;
        shift_enable = 0;
        cnt_load     = 0;
        cnt_dec      = 0;
        busy         = 1; // Genelde meşgul, sadece IDLE'da 0 olacak.
        done         = 0;

        case (state)
            IDLE: begin
                busy = 0; // Sadece IDLE iken yeni start kabul edebiliriz [cite: 18, 180]
            end

            LOAD: begin
                // Başlangıç değerlerini hazırla [cite: 182]
                ld_operands = 1; // Sayıları registerlara al
                clr_product = 1; // Sonucu sıfırla
                cnt_load    = 1; // Sayacı N'e kur
                busy        = 1;
            end

            RUN: begin
                // Shift-and-Add Algoritması [cite: 183-186]
                busy = 1;
                
                // 1. Eğer son bit 1 ise toplama yap (Algoritma gereği) [cite: 184]
                if (lsb_is_one) 
                    add_enable = 1;
                
                // 2. Her turda mutlaka kaydırma yap
                shift_enable = 1;
                
                // 3. Her turda sayacı azalt
                cnt_dec = 1;
            end

            DONE: begin
                busy = 0;
                done = 1; // Bitti sinyalini çak [cite: 187]
            end
        endcase
    end

endmodule